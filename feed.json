{
    "version": "https://jsonfeed.org/version/1",
    "title": "MyBlog",
    "description": "",
    "home_page_url": "https://github.com/quangminh2k3/my1blog.git",
    "feed_url": "https://github.com/quangminh2k3/my1blog.git/feed.json",
    "user_comment": "",
    "icon": "https://github.com/quangminh2k3/my1blog.git/media/website/concept-construction-page-site.jpg",
    "author": {
        "name": "Lâm Quang Minh"
    },
    "items": [
        {
            "id": "https://github.com/quangminh2k3/my1blog.git/blog-09_.html",
            "url": "https://github.com/quangminh2k3/my1blog.git/blog-09_.html",
            "title": "Blog 09_ Lập trình Multicast",
            "summary": "1. Tổng quan về Multicast Multicast là một phương pháp truyền dữ liệu cho nhiều máy nhận trong một mạng thông qua một nhóm địa chỉ multicast cụ thể. Thay vì gửi dữ liệu đến từng máy nhận riêng lẻ (unicast) hoặc gửi đến toàn&hellip;",
            "content_html": "<h4 data-pm-slice=\"1 1 []\">1. <strong>Tổng quan về Multicast</strong></h4>\n<p>Multicast là một phương pháp truyền dữ liệu cho nhiều máy nhận trong một mạng thông qua một nhóm địa chỉ multicast cụ thể. Thay vì gửi dữ liệu đến từng máy nhận riêng lẻ (unicast) hoặc gửi đến toàn bộ mạng (broadcast), multicast cho phép truyền dữ liệu hiệu quả đến một nhóm các máy nhận đăng ký.</p>\n<h5><strong>Đặc điểm của Multicast:</strong></h5>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Hiệu quả:</strong> Dữ liệu chỉ được gửi một lần từ nguồn và được sao chép bởi các router trong mạng để đến các thành viên trong nhóm multicast.</p>\n</li>\n<li>\n<p><strong>Nhóm địa chỉ multicast:</strong> Các địa chỉ IP từ <strong>224.0.0.0</strong> đến <strong>239.255.255.255</strong> được dành riêng cho multicast.</p>\n</li>\n<li>\n<p><strong>Ứng dụng:</strong> Multicast thường được sử dụng trong các ứng dụng phát sóng trực tiếp, hội nghị video, và chia sẻ dữ liệu thời gian thực.</p>\n</li>\n</ul>\n<div><hr></div>\n<h4>2. <strong>MulticastSocket</strong></h4>\n<p>Lớp <code>MulticastSocket</code> trong Java mở rộng lớp <code>DatagramSocket</code> và được thiết kế để hỗ trợ giao thức UDP với tính năng multicast.</p>\n<h5><strong>Các tính năng chính của MulticastSocket:</strong></h5>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p><strong>Tham gia nhóm (Join Group):</strong> MulticastSocket có thể tham gia một nhóm địa chỉ multicast để nhận dữ liệu.</p>\n</li>\n<li>\n<p><strong>Rời khỏi nhóm (Leave Group):</strong> MulticastSocket có thể rời khỏi một nhóm multicast khi không cần nhận dữ liệu nữa.</p>\n</li>\n<li>\n<p><strong>Gửi dữ liệu:</strong> Gửi các gói tin đến một địa chỉ multicast.</p>\n</li>\n</ol>\n<h5><strong>Các phương thức quan trọng:</strong></h5>\n<ul data-spread=\"false\">\n<li>\n<p><code>joinGroup(InetAddress group)</code>: Tham gia vào một nhóm multicast.</p>\n</li>\n<li>\n<p><code>leaveGroup(InetAddress group)</code>: Rời khỏi nhóm multicast.</p>\n</li>\n<li>\n<p><code>setTimeToLive(int ttl)</code>: Đặt giá trị Time-To-Live (TTL) để kiểm soát phạm vi truyền của gói tin multicast.</p>\n</li>\n<li>\n<p><code>send(DatagramPacket packet)</code>: Gửi một gói tin đến địa chỉ multicast.</p>\n</li>\n<li>\n<p><code>receive(DatagramPacket packet)</code>: Nhận gói tin từ nhóm multicast.</p>\n</li>\n</ul>\n<div><hr></div>\n<h4>3. <strong>Các bước lập trình Multicast</strong></h4>\n<h5><strong>3.1. Gửi dữ liệu Multicast</strong></h5>\n<p>Để gửi dữ liệu đến một nhóm multicast, cần thực hiện các bước sau:</p>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p><strong>Tạo một đối tượng </strong><code><strong>MulticastSocket</strong></code><strong>.</strong></p>\n</li>\n<li>\n<p><strong>Đặt TTL (tuỳ chọn):</strong> Quy định phạm vi của gói tin multicast.</p>\n</li>\n<li>\n<p><strong>Tạo gói tin DatagramPacket chứa dữ liệu.</strong></p>\n</li>\n<li>\n<p><strong>Gửi gói tin đến địa chỉ multicast.</strong></p>\n</li>\n</ol>\n<h6><strong>Ví dụ gửi dữ liệu Multicast:</strong></h6>\n<pre><code>import java.net.*;\n\npublic class MulticastSender {\n    public static void main(String[] args) {\n        try (MulticastSocket socket = new MulticastSocket()) {\n            String message = \"Hello, Multicast!\";\n            byte[] buffer = message.getBytes();\n\n            InetAddress group = InetAddress.getByName(\"230.0.0.0\"); // Địa chỉ multicast\n            int port = 4446; // Cổng multicast\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, group, port);\n\n            socket.setTimeToLive(1); // Phạm vi multicast (1 = cục bộ)\n            socket.send(packet);\n\n            System.out.println(\"Đã gửi: \" + message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<div><hr></div>\n<h5><strong>3.2. Nhận dữ liệu Multicast</strong></h5>\n<p>Để nhận dữ liệu từ một nhóm multicast, cần thực hiện các bước sau:</p>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p><strong>Tạo một đối tượng </strong><code><strong>MulticastSocket</strong></code><strong> lắng nghe trên một cổng.</strong></p>\n</li>\n<li>\n<p><strong>Tham gia vào nhóm multicast.</strong></p>\n</li>\n<li>\n<p><strong>Tạo bộ đệm (buffer) để chứa dữ liệu nhận.</strong></p>\n</li>\n<li>\n<p><strong>Nhận dữ liệu bằng phương thức </strong><code><strong>receive()</strong></code><strong>.</strong></p>\n</li>\n<li>\n<p><strong>Xử lý và hiển thị dữ liệu.</strong></p>\n</li>\n</ol>\n<h6><strong>Ví dụ nhận dữ liệu Multicast:</strong></h6>\n<pre><code>import java.net.*;\n\npublic class MulticastReceiver {\n    public static void main(String[] args) {\n        try (MulticastSocket socket = new MulticastSocket(4446)) { // Lắng nghe trên cổng 4446\n            InetAddress group = InetAddress.getByName(\"230.0.0.0\"); // Địa chỉ multicast\n            socket.joinGroup(group); // Tham gia nhóm\n\n            byte[] buffer = new byte[1024];\n\n            while (true) {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                socket.receive(packet);\n\n                String received = new String(packet.getData(), 0, packet.getLength());\n                System.out.println(\"Đã nhận: \" + received);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<div><hr></div>\n<h5><strong>3.3. Rời khỏi nhóm Multicast</strong></h5>\n<p>Nếu không cần nhận dữ liệu từ nhóm multicast, bạn có thể sử dụng phương thức <code>leaveGroup()</code> để rời nhóm.</p>\n<h6><strong>Ví dụ rời nhóm Multicast:</strong></h6>\n<pre><code>socket.leaveGroup(group);</code></pre>\n<div><hr></div>\n<h4>4. <strong>Kết luận</strong></h4>\n<p>Lập trình multicast với lớp <code>MulticastSocket</code> trong Java cung cấp một phương pháp hiệu quả để truyền dữ liệu đến nhiều máy nhận trong một nhóm. Tuy nhiên, để triển khai multicast hiệu quả trong môi trường thực tế, cần cân nhắc về phạm vi TTL, địa chỉ nhóm, và xử lý lỗi trong quá trình gửi/nhận dữ liệu.</p>\n<p> </p>",
            "author": {
                "name": "Lâm Quang Minh"
            },
            "tags": [
            ],
            "date_published": "2024-12-26T14:48:28+07:00",
            "date_modified": "2024-12-26T14:55:20+07:00"
        },
        {
            "id": "https://github.com/quangminh2k3/my1blog.git/blog-08_-lap-trinh-socket-cho-giao-thuc-udp.html",
            "url": "https://github.com/quangminh2k3/my1blog.git/blog-08_-lap-trinh-socket-cho-giao-thuc-udp.html",
            "title": "Blog 08_ Lập trình Socket cho giao thức UDP",
            "summary": "1. Giới Thiệu Lập trình socket cho giao thức UDP (User Datagram Protocol) là một kỹ thuật quan trọng trong việc xây dựng các ứng dụng mạng. UDP là giao thức phi kết nối, cung cấp cách truyền dữ liệu nhanh chóng nhưng không bảo&hellip;",
            "content_html": "<h2 data-pm-slice=\"1 1 []\">1. Giới Thiệu</h2>\n<p>Lập trình socket cho giao thức UDP (User Datagram Protocol) là một kỹ thuật quan trọng trong việc xây dựng các ứng dụng mạng. UDP là giao thức phi kết nối, cung cấp cách truyền dữ liệu nhanh chóng nhưng không bảo đảm tính toàn vẹn (reliability). Bài viết này sẽ tổng quan về giao thức UDP, hai lớp quan trọng trong Java là <strong>DatagramPacket</strong> và <strong>DatagramSocket</strong>, kèm theo ví dụ minh hoạ.</p>\n<div><hr></div>\n<h2>2. Tổng Quan Về Giao Thức UDP</h2>\n<h3>2.1. Khái Niệm</h3>\n<p>UDP là giao thức truyền dữ liệu dựa trên gói tin (<strong>datagram</strong>) và không yêu cầu kết nối trước khi truyền. Một vài đặc điểm chính:</p>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Nhanh chóng</strong>: UDP không yêu cầu quy trình bắt tay ba (three-way handshake) như TCP, nên truyền dữ liệu nhanh.</p>\n</li>\n<li>\n<p><strong>Phi kết nối</strong>: Không duy trì kết nối, giao thức UDP chỉ gửi gói tin đến địa chỉ đích.</p>\n</li>\n<li>\n<p><strong>Không đảm bảo</strong>: UDP không đảm bảo gói tin đến đúng thứ tự, không đảm bảo không bị mất dữ liệu.</p>\n</li>\n</ul>\n<p>UDP thường được sử dụng trong các ứng dụng thường xuyên truyền tải dữ liệu nhỏ, như streaming video/audio, DNS, hay game online.</p>\n<div><hr></div>\n<h2>3. Lớp DatagramPacket</h2>\n<h3>3.1. Khái Niệm</h3>\n<p><strong>DatagramPacket</strong> là lớp đại diện cho gói tin trong giao thức UDP. Mỗi gói tin chứa dữ liệu cũng như địa chỉ IP và cổng của máy nhận.</p>\n<h3>3.2. Tạo DatagramPacket</h3>\n<p>Khi gửi dữ liệu, ta sử dụng constructor:</p>\n<pre><code>DatagramPacket(byte[] data, int length, InetAddress address, int port)</code></pre>\n<ul data-spread=\"false\">\n<li>\n<p><strong>data</strong>: Mảng byte chứa dữ liệu.</p>\n</li>\n<li>\n<p><strong>length</strong>: Độ dài của dữ liệu.</p>\n</li>\n<li>\n<p><strong>address</strong>: Địa chỉ IP của máy nhận.</p>\n</li>\n<li>\n<p><strong>port</strong>: Cổng của máy nhận.</p>\n</li>\n</ul>\n<p>Khi nhận dữ liệu, ta khai báo constructor:</p>\n<pre><code>DatagramPacket(byte[] buffer, int length)</code></pre>\n<ul data-spread=\"false\">\n<li>\n<p><strong>buffer</strong>: Mảng byte để chứa dữ liệu nhận.</p>\n</li>\n<li>\n<p><strong>length</strong>: Độ dài buffer.</p>\n</li>\n</ul>\n<div><hr></div>\n<h2>4. Lớp DatagramSocket</h2>\n<h3>4.1. Khái Niệm</h3>\n<p><strong>DatagramSocket</strong> là lớp để gửi và nhận gói tin trong giao thức UDP. Socket đóng vai trò như một điểm giao tiếp cho giao thức UDP.</p>\n<h3>4.2. Tạo DatagramSocket</h3>\n<ul data-spread=\"false\">\n<li>\n<p>Khởi tạo server UDP:</p>\n</li>\n</ul>\n<pre><code>DatagramSocket socket = new DatagramSocket(int port);</code></pre>\n<ul data-spread=\"false\">\n<li>\n<p>Khởi tạo client UDP:</p>\n</li>\n</ul>\n<pre><code>DatagramSocket socket = new DatagramSocket();</code></pre>\n<h3>4.3. Gửi Dữ Liệu</h3>\n<p>Phương thức gửi gói tin:</p>\n<pre><code>socket.send(DatagramPacket packet);</code></pre>\n<h3>4.4. Nhận Dữ Liệu</h3>\n<p>Phương thức nhận gói tin:</p>\n<pre><code>socket.receive(DatagramPacket packet);</code></pre>\n<div><hr></div>\n<h2>5. Ví Dụ UDP Trong Java</h2>\n<h3>5.1. Server UDP</h3>\n<pre><code>import java.net.*;\n\npublic class UDPServer {\n    public static void main(String[] args) {\n        try (DatagramSocket socket = new DatagramSocket(7000)) {\n            byte[] buffer = new byte[1024];\n\n            while (true) {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                socket.receive(packet);\n\n                String received = new String(packet.getData(), 0, packet.getLength());\n                System.out.println(\"Nhận được: \" + received);\n\n                String response = \"Server đã nhận: \" + received;\n                byte[] responseBytes = response.getBytes();\n\n                DatagramPacket responsePacket = new DatagramPacket(\n                        responseBytes, responseBytes.length, packet.getAddress(), packet.getPort());\n                socket.send(responsePacket);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h3>5.2. Client UDP</h3>\n<pre><code>import java.net.*;\n\npublic class UDPClient {\n    public static void main(String[] args) {\n        try (DatagramSocket socket = new DatagramSocket()) {\n            String message = \"Xin chào Server!\";\n            byte[] buffer = message.getBytes();\n\n            InetAddress address = InetAddress.getByName(\"localhost\");\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 7000);\n            socket.send(packet);\n\n            byte[] responseBuffer = new byte[1024];\n            DatagramPacket responsePacket = new DatagramPacket(responseBuffer, responseBuffer.length);\n            socket.receive(responsePacket);\n\n            String response = new String(responsePacket.getData(), 0, responsePacket.getLength());\n            System.out.println(\"Phản hồi từ Server: \" + response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h3>5.3. Gửi Và Nhận Gói Tin Trong UDP</h3>\n<h4>Gửi Gói Tin</h4>\n<p>Để gửi gói tin UDP, bạn cần thực hiện các bước sau:</p>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p>Tạo một mảng byte chứa dữ liệu cần gửi.</p>\n</li>\n<li>\n<p>Tạo đối tượng <code>DatagramPacket</code> với dữ liệu, địa chỉ IP và cổng của máy nhận.</p>\n</li>\n<li>\n<p>Sử dụng phương thức <code>send()</code> của <code>DatagramSocket</code> để gửi gói tin.</p>\n</li>\n</ol>\n<p>Ví dụ gửi gói tin:</p>\n<pre><code>String message = \"Hello, UDP!\";\nbyte[] buffer = message.getBytes();\nInetAddress address = InetAddress.getByName(\"127.0.0.1\");\nint port = 7000;\nDatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);\nsocket.send(packet);</code></pre>\n<h4>Nhận Gói Tin</h4>\n<p>Để nhận gói tin UDP:</p>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p>Tạo một mảng byte làm bộ đệm để chứa dữ liệu nhận được.</p>\n</li>\n<li>\n<p>Tạo đối tượng <code>DatagramPacket</code> với bộ đệm này.</p>\n</li>\n<li>\n<p>Sử dụng phương thức <code>receive()</code> của <code>DatagramSocket</code> để nhận gói tin.</p>\n</li>\n</ol>\n<p>Ví dụ nhận gói tin:</p>\n<pre><code>byte[] buffer = new byte[1024];\nDatagramPacket packet = new DatagramPacket(buffer, buffer.length);\nsocket.receive(packet);\nString receivedMessage = new String(packet.getData(), 0, packet.getLength());\nSystem.out.println(\"Nhận được: \" + receivedMessage);</code></pre>\n<div><hr></div>\n<h2>6. Kết Luận</h2>\n<p>Lập trình socket với giao thức UDP cung cấp một giải pháp truyền tải nhanh nhất cho các ứng dụng có tính độ linh hoạt cao. Tuy nhiên, để đảm bảo tính toàn vẹn và thứ tự gói tin, các nhà phát triển cần xây dựng thêm logic phù hợp. Với Java, việc sử dụng lớp <strong>DatagramPacket</strong> và <strong>DatagramSocket</strong> giúp việc lập trình mạng trở nên dễ dàng và nhanh chóng.</p>",
            "author": {
                "name": "Lâm Quang Minh"
            },
            "tags": [
            ],
            "date_published": "2024-12-26T14:43:22+07:00",
            "date_modified": "2024-12-26T14:49:29+07:00"
        },
        {
            "id": "https://github.com/quangminh2k3/my1blog.git/blog-07_-ky-thuat-da-tien-tinh-va-tuan-tu-hoa-ung-dung-mang.html",
            "url": "https://github.com/quangminh2k3/my1blog.git/blog-07_-ky-thuat-da-tien-tinh-va-tuan-tu-hoa-ung-dung-mang.html",
            "title": "Blog 07_ Kỹ thuật đa tiến tình và tuần tự hóa ... Ứng dụng mạng",
            "summary": "1. Giới Thiệu Lập trình mạng là một lĩnh vực được sử dụng rộng rãi trong việc phát triển các hệ thống giao tiếp dữ liệu giữa các thiết bị. Trong đó, kỹ thuật đa tiến trình (multithreading) và tuần tự hóa (serialization) là hai&hellip;",
            "content_html": "<h2 data-pm-slice=\"1 1 []\">1. Giới Thiệu</h2>\n<p>Lập trình mạng là một lĩnh vực được sử dụng rộng rãi trong việc phát triển các hệ thống giao tiếp dữ liệu giữa các thiết bị. Trong đó, kỹ thuật đa tiến trình (multithreading) và tuần tự hóa (serialization) là hai kỹ thuật quản trọng giúp tối ưu hóa hiệu năng và linh hoạt trong việc xây dựng các ứng dụng mạng. Bài viết này sẽ trình bày chi tiết về hai kỹ thuật này, cách áp dụng trong môi trường Java, và một số ví dụ minh họạ.</p>\n<div><hr></div>\n<h2>2. Kỹ Thuật Đa Tiến Trình (Multithreading)</h2>\n<h3>2.1. Khái Niệm</h3>\n<p>Đa tiến trình (multithreading) là kỹ thuật cho phép chương trình thực thi nhiều tiến trình (được gọi là thread) cùng lúc. Mỗi thread hoạt động như một đơn vị thực thi độc lập trong chương trình.</p>\n<h3>2.2. Lợi ích Của Đa Tiến Trình</h3>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Hiệu năng cao</strong>: Cho phép chương trình thực thi các tác vụ độc lập song song, giảm thời gian chờ.</p>\n</li>\n<li>\n<p><strong>Khả năng đáp ứng tốt hơn</strong>: Ứng dụng có thể xử lý nhiều tác vụ song song như giao diện người dùng, truy vấn dữ liệu.</p>\n</li>\n<li>\n<p><strong>Khai thác tối ưu CPU</strong>: Nhiều thread cho phép khai thác tối đa tài nguyên CPU.</p>\n</li>\n</ul>\n<h3>2.3. Thread Trong Java</h3>\n<p>Trong Java, kỹ thuật đa tiến trình được hỗ trợ bởi lớp <code>Thread</code> và giao diện <code>Runnable</code>.</p>\n<h4>Tạo Thread Bằng Lớp <code>Thread</code></h4>\n<pre><code>class MyThread extends Thread {\n    public void run() {\n        System.out.println(\"Thread \" + Thread.currentThread().getId() + \" đang chạy.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 5; i++) {\n            MyThread thread = new MyThread();\n            thread.start();\n        }\n    }\n}</code></pre>\n<h4>Tạo Thread Bằng Giao Diện <code>Runnable</code></h4>\n<pre><code>class MyRunnable implements Runnable {\n    public void run() {\n        System.out.println(\"Thread \" + Thread.currentThread().getId() + \" đang chạy.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 5; i++) {\n            Thread thread = new Thread(new MyRunnable());\n            thread.start();\n        }\n    }\n}</code></pre>\n<h3>2.4. Đa Tiến Trình Trong Lập Trình Mạng</h3>\n<p>Trong lập trình mạng, đa tiến trình được sử dụng để xử lý nhiều client cùng lúc. Sau đây là ví dụ server xử lý nhiều client.</p>\n<h4>Ví Dụ: Server Đa Tiến Trình</h4>\n<pre><code>import java.io.*;\nimport java.net.*;\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    public void run() {\n        try {\n            InputStream input = socket.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n\n            OutputStream output = socket.getOutputStream();\n            PrintWriter writer = new PrintWriter(output, true);\n\n            String message;\n            while ((message = reader.readLine()) != null) {\n                System.out.println(\"Client: \" + message);\n                writer.println(\"Server đã nhận: \" + message);\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class MultiThreadedServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(7000)) {\n            System.out.println(\"Server đang lắng nghe trên cổng 7000...\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                System.out.println(\"Client kết nối.\");\n\n                ClientHandler handler = new ClientHandler(socket);\n                handler.start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<div><hr></div>\n<h2>3. Tuần Tự Hóa Đối Tượng (Serialization)</h2>\n<h3>3.1. Khái Niệm</h3>\n<p>Tuần tự hóa (“serialization”) là quá trình chuyển đổi trạng thái của đối tượng thành dữ liệu dạng byte (để truyền qua mạng hoặc lưu trữ). Trong Java, điều này được thực hiện bằng giao diện <code>Serializable</code>.</p>\n<h3>3.2. Ưu Điểm Của Tuần Tự Hóa</h3>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Lưu trữ dữ liệu</strong>: Lưu trữ trạng thái đối tượng.</p>\n</li>\n<li>\n<p><strong>Truyền dữ liệu qua mạng</strong>: Truyền trực tiếp đối tượng.</p>\n</li>\n</ul>\n<h3>3.3. Ví Dụ Tuần Tự Hóa</h3>\n<h4>Tuần Tự Hóa Đối Tượng</h4>\n<pre><code>import java.io.*;\n\nclass Student implements Serializable {\n    private String name;\n    private int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String toString() {\n        return \"Student{name='\" + name + \"', age=\" + age + \"}\";\n    }\n}\n\npublic class SerializationExample {\n    public static void main(String[] args) {\n        try {\n            // Tuần tự hóa\n            Student student = new Student(\"Nguyen Van A\", 20);\n            FileOutputStream fileOut = new FileOutputStream(\"student.ser\");\n            ObjectOutputStream out = new ObjectOutputStream(fileOut);\n            out.writeObject(student);\n            out.close();\n            fileOut.close();\n\n            // Phân tự hóa\n            FileInputStream fileIn = new FileInputStream(\"student.ser\");\n            ObjectInputStream in = new ObjectInputStream(fileIn);\n            Student deserializedStudent = (Student) in.readObject();\n            in.close();\n            fileIn.close();\n\n            System.out.println(\"Student sau khi phân tự hóa: \" + deserializedStudent);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<div><hr></div>\n<h2>4. Kết Luận</h2>\n<p>Kỹ thuật đa tiến trình và tuần tự hóa đóng vai trò quản trọng trong việc xây dựng các ứng dụng mạng. Chúng giúp nâng cao hiệu năng và tính linh hoạt trong xử lý dữ liệu, mang đến những trải nghiệm tốt nhất cho người dùng.</p>",
            "author": {
                "name": "Lâm Quang Minh"
            },
            "tags": [
            ],
            "date_published": "2024-12-26T13:59:59+07:00",
            "date_modified": "2024-12-26T14:34:48+07:00"
        },
        {
            "id": "https://github.com/quangminh2k3/my1blog.git/blog-06_.html",
            "url": "https://github.com/quangminh2k3/my1blog.git/blog-06_.html",
            "title": "Blog 06_ Lập trình Socket cho giao thức TCP",
            "summary": "1. Giới Thiệu Về Lập Trình Socket Lập trình socket là kỹ thuật cho phép hai ứng dụng trên các máy tính khác nhau hoặc cùng một máy tính giao tiếp với nhau thông qua mạng. Socket hỗ trợ các giao thức như TCP (Transmission&hellip;",
            "content_html": "<h2 data-pm-slice=\"1 1 []\">1. Giới Thiệu Về Lập Trình Socket</h2>\n<p>Lập trình socket là kỹ thuật cho phép hai ứng dụng trên các máy tính khác nhau hoặc cùng một máy tính giao tiếp với nhau thông qua mạng. Socket hỗ trợ các giao thức như <strong>TCP (Transmission Control Protocol)</strong> và <strong>UDP (User Datagram Protocol)</strong>.</p>\n<h3>TCP (Transmission Control Protocol)</h3>\n<p>TCP là giao thức kết nối đáng tin cậy, đảm bảo dữ liệu được truyền đầy đủ và theo thứ tự. Nó thích hợp cho các ứng dụng yêu cầu độ chính xác cao như email, trình duyệt web và truyền tệp.</p>\n<div><hr></div>\n<h2>2. Mô Hình Khách Chủ (Client/Server)</h2>\n<p>Mô hình client/server là một kiến trúc phổ biến trong lập trình mạng, nơi:</p>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Client (Khách):</strong> Gửi yêu cầu đến server.</p>\n</li>\n<li>\n<p><strong>Server (Chủ):</strong> Xử lý yêu cầu và trả về kết quả cho client.</p>\n</li>\n</ul>\n<h3>Quy Trình Kết Nối TCP</h3>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p><strong>Server Khởi Động:</strong> Mở một socket, lắng nghe các yêu cầu từ client.</p>\n</li>\n<li>\n<p><strong>Client Kết Nối:</strong> Tạo một socket và kết nối đến server.</p>\n</li>\n<li>\n<p><strong>Trao Đổi Dữ Liệu:</strong> Server và client truyền tải dữ liệu qua luồng I/O.</p>\n</li>\n<li>\n<p><strong>Đóng Kết Nối:</strong> Giải phóng tài nguyên sau khi hoàn tất.</p>\n</li>\n</ol>\n<div><hr></div>\n<h2>3. Socket Trong Java</h2>\n<h3>Server Socket</h3>\n<p>Server sử dụng lớp <code>ServerSocket</code> để lắng nghe các yêu cầu từ client.</p>\n<h3>Client Socket</h3>\n<p>Client sử dụng lớp <code>Socket</code> để kết nối đến server.</p>\n<h3>Ví Dụ 1: Server và Client Đơn Giản</h3>\n<h4>Server</h4>\n<pre><code>import java.io.*;\nimport java.net.*;\n\npublic class SimpleServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(5000)) {\n            System.out.println(\"Server đang lắng nghe trên cổng 5000...\");\n\n            Socket socket = serverSocket.accept();\n            System.out.println(\"Client đã kết nối.\");\n\n            InputStream input = socket.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n\n            String message = reader.readLine();\n            System.out.println(\"Client: \" + message);\n\n            OutputStream output = socket.getOutputStream();\n            PrintWriter writer = new PrintWriter(output, true);\n            writer.println(\"Server đã nhận tin nhắn của bạn: \" + message);\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h4>Client</h4>\n<pre><code>import java.io.*;\nimport java.net.*;\n\npublic class SimpleClient {\n    public static void main(String[] args) {\n        try (Socket socket = new Socket(\"localhost\", 5000)) {\n            OutputStream output = socket.getOutputStream();\n            PrintWriter writer = new PrintWriter(output, true);\n            writer.println(\"Xin chào server!\");\n\n            InputStream input = socket.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n            String response = reader.readLine();\n            System.out.println(\"Server: \" + response);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h3>Giải Thích</h3>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p><strong>ServerSocket:</strong> Được sử dụng để lắng nghe các yêu cầu từ client.</p>\n</li>\n<li>\n<p><strong>Socket:</strong> Được sử dụng để tạo kết nối giữa client và server.</p>\n</li>\n<li>\n<p><strong>Streams:</strong> Để truyền và nhận dữ liệu giữa hai đầu kết nối.</p>\n</li>\n</ol>\n<div><hr></div>\n<h2>4. Truyền Tin Qua Socket</h2>\n<h3>Giao Tiếp Hai Chiều</h3>\n<p>Socket hỗ trợ giao tiếp hai chiều (full-duplex), nghĩa là dữ liệu có thể được gửi và nhận cùng lúc.</p>\n<h3>Ví Dụ 2: Chat Giữa Client Và Server</h3>\n<h4>Server</h4>\n<pre><code>import java.io.*;\nimport java.net.*;\n\npublic class ChatServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(6000)) {\n            System.out.println(\"Server sẵn sàng chờ kết nối...\");\n            Socket socket = serverSocket.accept();\n            System.out.println(\"Client đã kết nối!\");\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);\n\n            String message;\n            while ((message = reader.readLine()) != null) {\n                System.out.println(\"Client: \" + message);\n                writer.println(\"Server đã nhận: \" + message);\n            }\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h4>Client</h4>\n<pre><code>import java.io.*;\nimport java.net.*;\n\npublic class ChatClient {\n    public static void main(String[] args) {\n        try (Socket socket = new Socket(\"localhost\", 6000)) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);\n\n            BufferedReader console = new BufferedReader(new InputStreamReader(System.in));\n            String message;\n            while ((message = console.readLine()) != null) {\n                writer.println(message);\n                System.out.println(\"Server: \" + reader.readLine());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<div><hr></div>\n<h2>5. Kết Luận</h2>\n<p>Lập trình socket trong Java là một kỹ thuật mạnh mẽ để phát triển các ứng dụng mạng dựa trên giao thức TCP. Với mô hình client/server và khả năng truyền tin qua socket, lập trình viên có thể xây dựng các hệ thống giao tiếp dữ liệu hiệu quả và linh hoạt.</p>",
            "author": {
                "name": "Lâm Quang Minh"
            },
            "tags": [
            ],
            "date_published": "2024-12-26T13:42:53+07:00",
            "date_modified": "2024-12-26T13:43:12+07:00"
        },
        {
            "id": "https://github.com/quangminh2k3/my1blog.git/blog-05_-quan-ly-dia-chi-ket-noi-mang.html",
            "url": "https://github.com/quangminh2k3/my1blog.git/blog-05_-quan-ly-dia-chi-ket-noi-mang.html",
            "title": "Blog 05_ Quản lý địa chỉ kết nối mạng",
            "summary": "1. Lớp InetAddress Giới Thiệu Lớp InetAddress trong Java được sử dụng để biểu diễn địa chỉ IP của một máy chủ hoặc máy khách trên mạng. Nó hỗ trợ xử lý cả địa chỉ IPv4 và IPv6. getByName(String host): Lấy địa chỉ IP từ&hellip;",
            "content_html": "<h2 data-pm-slice=\"1 1 []\">1. Lớp InetAddress</h2>\n<h3>Giới Thiệu</h3>\n<p>Lớp <code>InetAddress</code> trong Java được sử dụng để biểu diễn địa chỉ IP của một máy chủ hoặc máy khách trên mạng. Nó hỗ trợ xử lý cả địa chỉ IPv4 và IPv6.</p>\n<h3>Các Phương Thức Chính</h3>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p><strong>getByName(String host):</strong> Lấy địa chỉ IP từ tên miền hoặc địa chỉ IP cụ thể.</p>\n</li>\n<li>\n<p><strong>getAllByName(String host):</strong> Lấy tất cả các địa chỉ IP liên quan đến một tên miền cụ thể.</p>\n</li>\n<li>\n<p><strong>getLocalHost():</strong> Lấy thông tin địa chỉ IP của máy tính đang chạy chương trình.</p>\n</li>\n<li>\n<p><strong>getHostName():</strong> Trả về tên máy chủ của địa chỉ IP.</p>\n</li>\n<li>\n<p><strong>getHostAddress():</strong> Trả về địa chỉ IP dưới dạng chuỗi.</p>\n</li>\n</ol>\n<h3>Ví Dụ</h3>\n<pre><code>import java.net.*;\n\npublic class InetAddressExample {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"www.example.com\");\n            System.out.println(\"Host Name: \" + address.getHostName());\n            System.out.println(\"IP Address: \" + address.getHostAddress());\n\n            InetAddress localAddress = InetAddress.getLocalHost();\n            System.out.println(\"Local Host Name: \" + localAddress.getHostName());\n            System.out.println(\"Local IP Address: \" + localAddress.getHostAddress());\n\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h3>Chức Năng Chính</h3>\n<ul data-spread=\"false\">\n<li>\n<p>Truy vấn địa chỉ IP của tên miền hoặc máy chủ.</p>\n</li>\n<li>\n<p>Hỗ trợ xử lý IPv4 và IPv6.</p>\n</li>\n<li>\n<p>Lấy thông tin địa chỉ cục bộ của hệ thống.</p>\n</li>\n</ul>\n<div><hr></div>\n<h2>2. Lớp URL</h2>\n<h3>Giới Thiệu</h3>\n<p>Lớp <code>URL</code> (Uniform Resource Locator) đại diện cho một địa chỉ tài nguyên trên Internet như trang web, hình ảnh hoặc tệp tin.</p>\n<h3>Các Thành Phần Của URL</h3>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p><strong>Protocol:</strong> Giao thức sử dụng, ví dụ: HTTP, HTTPS, FTP.</p>\n</li>\n<li>\n<p><strong>Host:</strong> Tên miền hoặc địa chỉ IP của máy chủ.</p>\n</li>\n<li>\n<p><strong>Port:</strong> Cổng kết nối (mặc định là 80 cho HTTP và 443 cho HTTPS).</p>\n</li>\n<li>\n<p><strong>Path:</strong> Đường dẫn đến tài nguyên.</p>\n</li>\n<li>\n<p><strong>Query:</strong> Tham số truyền qua URL.</p>\n</li>\n</ol>\n<h3>Các Phương Thức Chính</h3>\n<ul data-spread=\"false\">\n<li>\n<p><strong>getProtocol():</strong> Trả về giao thức được sử dụng.</p>\n</li>\n<li>\n<p><strong>getHost():</strong> Trả về tên máy chủ.</p>\n</li>\n<li>\n<p><strong>getPort():</strong> Trả về số cổng.</p>\n</li>\n<li>\n<p><strong>getFile():</strong> Trả về đường dẫn và tham số truy vấn.</p>\n</li>\n<li>\n<p><strong>openStream():</strong> Mở kết nối đến tài nguyên và trả về luồng dữ liệu.</p>\n</li>\n</ul>\n<h3>Ví Dụ</h3>\n<pre><code>import java.net.*;\n\npublic class URLExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"https://www.example.com/index.html?name=test\");\n            System.out.println(\"Protocol: \" + url.getProtocol());\n            System.out.println(\"Host: \" + url.getHost());\n            System.out.println(\"Port: \" + url.getPort());\n            System.out.println(\"Path: \" + url.getPath());\n            System.out.println(\"Query: \" + url.getQuery());\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h3>Chức Năng Chính</h3>\n<ul data-spread=\"false\">\n<li>\n<p>Phân tích cú pháp URL.</p>\n</li>\n<li>\n<p>Truy vấn thông tin chi tiết về URL.</p>\n</li>\n<li>\n<p>Hỗ trợ truy cập và xử lý tài nguyên qua mạng.</p>\n</li>\n</ul>\n<div><hr></div>\n<h2>3. Lớp URLConnection</h2>\n<h3>Giới Thiệu</h3>\n<p>Lớp <code>URLConnection</code> cho phép thiết lập kết nối mạng với một URL cụ thể và thực hiện truyền dữ liệu giữa máy khách và máy chủ.</p>\n<h3>Các Phương Thức Chính</h3>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p><strong>openConnection():</strong> Tạo kết nối tới URL.</p>\n</li>\n<li>\n<p><strong>connect():</strong> Thiết lập kết nối vật lý.</p>\n</li>\n<li>\n<p><strong>getInputStream():</strong> Đọc dữ liệu từ máy chủ.</p>\n</li>\n<li>\n<p><strong>getOutputStream():</strong> Gửi dữ liệu tới máy chủ.</p>\n</li>\n<li>\n<p><strong>setRequestProperty(String key, String value):</strong> Thiết lập tiêu đề yêu cầu HTTP.</p>\n</li>\n</ol>\n<h3>Ví Dụ</h3>\n<h4>Đọc Dữ Liệu Từ URL</h4>\n<pre><code>import java.io.*;\nimport java.net.*;\n\npublic class URLConnectionExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"https://www.example.com\");\n            URLConnection connection = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h4>Gửi Dữ Liệu Tới Máy Chủ</h4>\n<pre><code>import java.io.*;\nimport java.net.*;\n\npublic class PostExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"https://www.example.com/api\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            DataOutputStream out = new DataOutputStream(connection.getOutputStream());\n            out.writeBytes(\"param1=value1&amp;param2=value2\");\n            out.flush();\n            out.close();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h3>Chức Năng Chính</h3>\n<ul data-spread=\"false\">\n<li>\n<p>Thiết lập kết nối HTTP/HTTPS.</p>\n</li>\n<li>\n<p>Đọc và ghi dữ liệu từ/đến máy chủ.</p>\n</li>\n<li>\n<p>Hỗ trợ giao tiếp với API và dịch vụ web.</p>\n</li>\n</ul>\n<div><hr></div>\n<h2>Kết Luận</h2>\n<p>Lớp <code>InetAddress</code>, <code>URL</code>, và <code>URLConnection</code> cung cấp các công cụ mạnh mẽ để quản lý địa chỉ mạng, xử lý URL và kết nối với máy chủ. Chúng là những thành phần cốt lõi để xây dựng các ứng dụng mạng hiện đại và an toàn.</p>",
            "author": {
                "name": "Lâm Quang Minh"
            },
            "tags": [
            ],
            "date_published": "2024-12-26T13:28:16+07:00",
            "date_modified": "2024-12-26T13:37:19+07:00"
        },
        {
            "id": "https://github.com/quangminh2k3/my1blog.git/blog-04_-lap-trinh-da-tuyen.html",
            "url": "https://github.com/quangminh2k3/my1blog.git/blog-04_-lap-trinh-da-tuyen.html",
            "title": "Blog 04_ Lập trình đa tuyến",
            "summary": "1. Giới Thiệu Về Lập Trình Đa Tuyến Lập trình đa tuyến (Multithreading) là kỹ thuật cho phép một chương trình thực thi nhiều luồng (threads) đồng thời để cải thiện hiệu suất và khả năng phản hồi. Mỗi luồng là một luồng điều khiển&hellip;",
            "content_html": "<h2 data-pm-slice=\"1 1 []\">1. Giới Thiệu Về Lập Trình Đa Tuyến</h2>\n<p>Lập trình đa tuyến (Multithreading) là kỹ thuật cho phép một chương trình thực thi nhiều luồng (threads) đồng thời để cải thiện hiệu suất và khả năng phản hồi. Mỗi luồng là một luồng điều khiển riêng biệt có thể thực thi độc lập trong cùng một tiến trình.</p>\n<h3>Ưu Điểm Của Đa Tuyến</h3>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p><strong>Tăng Hiệu Suất:</strong> Xử lý song song giúp tận dụng tối đa tài nguyên CPU.</p>\n</li>\n<li>\n<p><strong>Khả Năng Phản Hồi Tốt Hơn:</strong> Ứng dụng có thể phản hồi nhanh chóng với các yêu cầu từ người dùng.</p>\n</li>\n<li>\n<p><strong>Chia Sẻ Tài Nguyên:</strong> Các luồng trong cùng một tiến trình có thể chia sẻ bộ nhớ và tài nguyên dễ dàng.</p>\n</li>\n</ol>\n<div><hr></div>\n<h2>2. Lớp Thread Trong Java</h2>\n<h3>Khởi Tạo Thread</h3>\n<p>Có hai cách để tạo luồng trong Java:</p>\n<ol start=\"1\" data-spread=\"false\">\n<li>\n<p><strong>Kế Thừa lớp Thread:</strong></p>\n</li>\n</ol>\n<pre><code>class MyThread extends Thread {\n    public void run() {\n        System.out.println(\"Thread đang chạy...\");\n    }\n}\n\npublic class TestThread {\n    public static void main(String[] args) {\n        MyThread t1 = new MyThread();\n        t1.start(); // Bắt đầu luồng\n    }\n}</code></pre>\n<ol start=\"2\" data-spread=\"false\">\n<li>\n<p><strong>Triển Khai Giao Diện Runnable:</strong></p>\n</li>\n</ol>\n<pre><code>class MyRunnable implements Runnable {\n    public void run() {\n        System.out.println(\"Runnable đang chạy...\");\n    }\n}\n\npublic class TestRunnable {\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new MyRunnable());\n        t1.start(); // Bắt đầu luồng\n    }\n}</code></pre>\n<div><hr></div>\n<h2>3. Đồng Bộ Hóa (Synchronization)</h2>\n<h3>Vấn Đề Đồng Bộ Hóa</h3>\n<p>Khi nhiều luồng cùng truy cập vào một tài nguyên chung, xung đột dữ liệu có thể xảy ra. Để giải quyết vấn đề này, Java cung cấp cơ chế <strong>đồng bộ hóa (synchronization)</strong>.</p>\n<h3>Ví Dụ Không Đồng Bộ</h3>\n<pre><code>class Counter {\n    int count = 0;\n\n    public void increment() {\n        count++;\n    }\n}\n\npublic class TestSync {\n    public static void main(String[] args) {\n        Counter counter = new Counter();\n\n        Thread t1 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) counter.increment();\n        });\n\n        Thread t2 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) counter.increment();\n        });\n\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"Count: \" + counter.count);\n    }\n}</code></pre>\n<p><strong>Kết Quả:</strong> Giá trị của <code>count</code> có thể không đúng do điều kiện tranh chấp.</p>\n<h3>Giải Pháp Đồng Bộ Hóa</h3>\n<p>Sử dụng từ khóa <code>synchronized</code> để đảm bảo chỉ một luồng có thể truy cập vào phương thức cùng lúc:</p>\n<pre><code>class Counter {\n    int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n}</code></pre>\n<div><hr></div>\n<h2>4. Trao Đổi Dữ Liệu Giữa Các Luồng</h2>\n<h3>Sử Dụng wait() và notify()</h3>\n<p>Java cung cấp các phương thức <code>wait()</code>, <code>notify()</code>, và <code>notifyAll()</code> để quản lý việc trao đổi dữ liệu giữa các luồng.</p>\n<h3>Ví Dụ</h3>\n<pre><code>class Data {\n    private String message;\n\n    public synchronized void send(String msg) {\n        this.message = msg;\n        notify(); // Báo hiệu luồng nhận có thể tiếp tục\n    }\n\n    public synchronized String receive() {\n        try {\n            wait(); // Chờ cho đến khi nhận được dữ liệu\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return message;\n    }\n}\n\nclass Sender extends Thread {\n    private Data data;\n\n    Sender(Data data) {\n        this.data = data;\n    }\n\n    public void run() {\n        data.send(\"Hello from Sender!\");\n    }\n}\n\nclass Receiver extends Thread {\n    private Data data;\n\n    Receiver(Data data) {\n        this.data = data;\n    }\n\n    public void run() {\n        System.out.println(data.receive());\n    }\n}\n\npublic class TestCommunication {\n    public static void main(String[] args) {\n        Data data = new Data();\n        Sender sender = new Sender(data);\n        Receiver receiver = new Receiver(data);\n        sender.start();\n        receiver.start();\n    }\n}</code></pre>\n<div><hr></div>\n<h2>5. Executor Framework</h2>\n<p>Java cung cấp <strong>Executor Framework</strong> để quản lý các luồng một cách hiệu quả.</p>\n<h3>Ví Dụ</h3>\n<pre><code>import java.util.concurrent.*;\n\npublic class ExecutorExample {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n\n        Runnable worker1 = () -&gt; System.out.println(\"Worker 1 đang chạy...\");\n        Runnable worker2 = () -&gt; System.out.println(\"Worker 2 đang chạy...\");\n\n        executor.execute(worker1);\n        executor.execute(worker2);\n\n        executor.shutdown();\n    }\n}</code></pre>\n<div><hr></div>\n<h2>Kết Luận</h2>\n<p>Lập trình đa tuyến trong Java là một công cụ mạnh mẽ để phát triển các ứng dụng hiệu suất cao. Bằng cách sử dụng các lớp <code>Thread</code>, <code>Runnable</code>, đồng bộ hóa và các cơ chế trao đổi dữ liệu, lập trình viên có thể dễ dàng quản lý luồng và xử lý đồng thời một cách an toàn.</p>",
            "author": {
                "name": "Lâm Quang Minh"
            },
            "tags": [
            ],
            "date_published": "2024-12-26T13:19:54+07:00",
            "date_modified": "2024-12-26T13:39:17+07:00"
        },
        {
            "id": "https://github.com/quangminh2k3/my1blog.git/blog-03_.html",
            "url": "https://github.com/quangminh2k3/my1blog.git/blog-03_.html",
            "title": "Blog 03_ Tổng quan về lập trình mạng",
            "summary": "Tổng Quan Về Lập Trình Mạng 1. Lập Trình Mạng Là Gì? Lập trình mạng là quá trình xây dựng các ứng dụng phần mềm có khả năng giao tiếp và truyền dữ liệu qua mạng máy tính. Nó cho phép các thiết bị khác&hellip;",
            "content_html": "<h3 data-pm-slice=\"1 1 []\">Tổng Quan Về Lập Trình Mạng</h3>\n<h4>1. Lập Trình Mạng Là Gì?</h4>\n<p>Lập trình mạng là quá trình xây dựng các ứng dụng phần mềm có khả năng giao tiếp và truyền dữ liệu qua mạng máy tính. Nó cho phép các thiết bị khác nhau kết nối và chia sẻ thông tin, từ đó tạo ra các hệ thống phân tán và ứng dụng web động.</p>\n<p>Lập trình mạng sử dụng các giao thức truyền thông để đảm bảo dữ liệu được gửi và nhận đúng cách giữa các thiết bị. Nó là một phần quan trọng trong phát triển ứng dụng hiện đại như các ứng dụng web, trò chuyện trực tuyến, dịch vụ phát trực tuyến và IoT.</p>\n<p>                      <img loading=\"lazy\" src=\"https://gpcoder.com/wp-content/uploads/2018/03/java-networking.png\" alt=\"Lập trình mạng với java - GP Coder (Lập trình Java)\" width=\"468\" height=\"319\" data-is-external-image=\"true\"></p>\n<div><hr></div>\n<h4>2. Vai Trò Của Ứng Dụng Mạng</h4>\n<p>Ứng dụng mạng đóng vai trò then chốt trong việc kết nối người dùng và thiết bị. Dưới đây là một số vai trò quan trọng:</p>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Trao Đổi Thông Tin:</strong> Hỗ trợ truyền dữ liệu giữa các thiết bị thông qua mạng nội bộ hoặc Internet.</p>\n</li>\n<li>\n<p><strong>Giao Tiếp Theo Thời Gian Thực:</strong> Các ứng dụng như tin nhắn tức thời hoặc gọi video hoạt động theo cơ chế giao tiếp ngay lập tức.</p>\n</li>\n<li>\n<p><strong>Chia Sẻ Tài Nguyên:</strong> Cho phép nhiều người dùng truy cập chung một tài nguyên, chẳng hạn như máy in, máy chủ hoặc cơ sở dữ liệu.</p>\n</li>\n<li>\n<p><strong>Hỗ Trợ Thương Mại Điện Tử:</strong> Các hệ thống thanh toán trực tuyến và giỏ hàng điện tử giúp người dùng mua sắm qua mạng dễ dàng.</p>\n</li>\n<li>\n<p><strong>Quản Lý Từ Xa:</strong> Điều khiển thiết bị và giám sát hệ thống từ xa thông qua mạng.</p>\n</li>\n</ul>\n<div><hr></div>\n<h4>3. Các Giao Thức Mạng Cơ Bản</h4>\n<p>Giao thức mạng là tập hợp các quy tắc xác định cách thức trao đổi dữ liệu trên mạng. Một số giao thức phổ biến gồm:</p>\n<p><strong>1. TCP/IP (Transmission Control Protocol/Internet Protocol):</strong></p>\n<ul data-spread=\"false\">\n<li>\n<p><strong>TCP</strong> đảm bảo dữ liệu được truyền tin cậy và theo đúng thứ tự.</p>\n</li>\n<li>\n<p><strong>IP</strong> định tuyến dữ liệu từ nguồn đến đích thông qua địa chỉ IP.</p>\n</li>\n</ul>\n<p><strong>2. HTTP/HTTPS (HyperText Transfer Protocol):</strong></p>\n<ul data-spread=\"false\">\n<li>\n<p>Được sử dụng để truyền siêu văn bản trên World Wide Web.</p>\n</li>\n<li>\n<p><strong>HTTPS</strong> bổ sung thêm lớp mã hóa SSL/TLS để bảo mật dữ liệu.</p>\n</li>\n</ul>\n<p><strong>3. FTP (File Transfer Protocol):</strong></p>\n<ul data-spread=\"false\">\n<li>\n<p>Giao thức dùng để truyền tải tập tin giữa các máy tính.</p>\n</li>\n</ul>\n<p><strong>4. SMTP và POP3/IMAP:</strong></p>\n<ul data-spread=\"false\">\n<li>\n<p><strong>SMTP</strong> (Simple Mail Transfer Protocol) được sử dụng để gửi email.</p>\n</li>\n<li>\n<p><strong>POP3</strong> (Post Office Protocol) và <strong>IMAP</strong> (Internet Message Access Protocol) để nhận email.</p>\n</li>\n</ul>\n<p><strong>5. WebSocket:</strong></p>\n<ul data-spread=\"false\">\n<li>\n<p>Hỗ trợ giao tiếp hai chiều giữa máy khách và máy chủ, thích hợp cho các ứng dụng thời gian thực như trò chuyện hoặc game trực tuyến.</p>\n</li>\n</ul>\n<p><strong>6. DNS (Domain Name System):</strong></p>\n<ul data-spread=\"false\">\n<li>\n<p>Chuyển đổi tên miền dễ đọc thành địa chỉ IP để kết nối các máy chủ.</p>\n</li>\n</ul>\n<div><hr></div>\n<h4>4. Các Công Cụ Và Công Nghệ Phổ Biến Trong Lập Trình Mạng</h4>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Socket Programming:</strong> Cho phép tạo kết nối mạng giữa hai ứng dụng thông qua giao thức TCP hoặc UDP.</p>\n</li>\n<li>\n<p><strong>API RESTful và GraphQL:</strong> Hỗ trợ xây dựng giao diện lập trình ứng dụng để giao tiếp giữa các hệ thống khác nhau.</p>\n</li>\n<li>\n<p><strong>Frameworks phổ biến:</strong> Node.js (JavaScript), Flask/Django (Python), Spring Boot (Java).</p>\n</li>\n<li>\n<p><strong>Công nghệ mã hóa:</strong> SSL/TLS để đảm bảo an toàn dữ liệu khi truyền qua mạng.</p>\n</li>\n</ul>\n<div><hr></div>\n<h4>5. Tầm Quan Trọng Của Bảo Mật Mạng</h4>\n<p>Lập trình mạng không thể thiếu yếu tố bảo mật để bảo vệ dữ liệu trước các cuộc tấn công mạng. Các kỹ thuật bảo mật bao gồm:</p>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Mã hóa dữ liệu:</strong> Bảo vệ dữ liệu khi truyền qua mạng bằng các thuật toán mã hóa như AES hoặc RSA.</p>\n</li>\n<li>\n<p><strong>Chứng chỉ số (SSL/TLS):</strong> Đảm bảo kết nối an toàn giữa máy chủ và máy khách.</p>\n</li>\n<li>\n<p><strong>Tường lửa (Firewall):</strong> Ngăn chặn truy cập trái phép.</p>\n</li>\n<li>\n<p><strong>VPN (Virtual Private Network):</strong> Tạo kết nối bảo mật qua mạng công cộng.</p>\n</li>\n</ul>\n<div><hr></div>\n<h3>Kết Luận</h3>\n<p>Lập trình mạng là một lĩnh vực không thể thiếu trong phát triển phần mềm hiện đại. Nó mở ra nhiều cơ hội để tạo ra các ứng dụng kết nối mạnh mẽ và an toàn. Việc nắm vững các giao thức, công cụ và phương pháp bảo mật sẽ giúp lập trình viên xây dựng những hệ thống hiệu quả và đáng tin cậy. Để bắt đầu, hãy thực hành lập trình socket và tìm hiểu các API RESTful, đồng thời luôn chú trọng đến bảo mật trong mọi bước phát triển ứng dụng mạng.</p>",
            "author": {
                "name": "Lâm Quang Minh"
            },
            "tags": [
            ],
            "date_published": "2024-12-26T12:58:39+07:00",
            "date_modified": "2024-12-26T13:11:12+07:00"
        },
        {
            "id": "https://github.com/quangminh2k3/my1blog.git/blog-02_.html",
            "url": "https://github.com/quangminh2k3/my1blog.git/blog-02_.html",
            "title": "Blog 02_ Giới thiệu về JavaScript",
            "summary": "JavaScript Là Gì? JavaScript (JS) là một ngôn ngữ lập trình mạnh mẽ, được sử dụng rộng rãi để phát triển các ứng dụng web. Ra đời vào năm 1995 bởi Brendan Eich, JavaScript ban đầu được thiết kế để tăng cường tính tương tác&hellip;",
            "content_html": "<h2>JavaScript Là Gì?</h2>\n<p>JavaScript (JS) là một ngôn ngữ lập trình mạnh mẽ, được sử dụng rộng rãi để phát triển các ứng dụng web. Ra đời vào năm 1995 bởi Brendan Eich, JavaScript ban đầu được thiết kế để tăng cường tính tương tác cho các trang web. Khác với Java, JavaScript là một ngôn ngữ dựa trên trình duyệt, mang đến khả năng xử lý động trên các ứng dụng web.</p>\n<h3>Vai Trò Của JavaScript Trong Phát Triển Web</h3>\n<ul>\n<li><strong>Front-end</strong>: JavaScript giúp tạo ra các giao diện người dùng sinh động và thân thiện. Nó thường được kết hợp với HTML và CSS để phát triển các ứng dụng web hiện đại.</li>\n<li><strong>Back-end</strong>: Với sự ra đời của Node.js, JavaScript đã mở rộng phạm vi của mình, cho phép lập trình viên xây dựng máy chủ và xử lý các ứng dụng phía máy chủ.</li>\n<li><strong>Full-stack</strong>: Một lập trình viên JavaScript hiện nay có thể làm việc ở cả front-end và back-end, biến JavaScript trở thành một công cụ đa năng.</li>\n</ul>\n<hr>\n<h2>Tại Sao Nên Học JavaScript?</h2>\n<ol>\n<li><strong>Ngôn Ngữ Được Yêu Thích Hàng Đầu</strong>: JavaScript đã giữ vững vị trí là ngôn ngữ phổ biến nhất trên thế giới theo khảo sát của Stack Overflow trong nhiều năm.</li>\n<li><strong>Cộng Đồng Lớn Mạnh</strong>: Hàng triệu lập trình viên sử dụng JavaScript, cung cấp nhiều tài liệu, thư viện và hỗ trợ từ cộng đồng.</li>\n<li><strong>Tính Ứng Dụng Cao</strong>: Từ việc xây dựng trang web, phát triển ứng dụng di động đến xử lý IoT, JavaScript đều có mặt.</li>\n</ol>\n<hr>\n<h2>Cách Học JavaScript Hiệu Quả</h2>\n<h3>1. <strong>Thiết Lập Môi Trường Học Tập</strong></h3>\n<ul>\n<li><strong>Công cụ cần thiết</strong>: Một trình duyệt hiện đại (Chrome, Firefox) và một trình soạn thảo mã nguồn (VS Code, Sublime Text).</li>\n<li><strong>Viết và chạy mã đầu tiên</strong>: Tạo file HTML và kết nối file JavaScript để chạy chương trình \"Hello, World!\".</li>\n</ul>\n<h3>2. <strong>Học Qua Ví Dụ Thực Tế</strong></h3>\n<ul>\n<li>Tạo các hiệu ứng động trên trang web như bật/tắt đèn (light switch).</li>\n<li>Xây dựng các ứng dụng đơn giản như máy tính hoặc danh sách việc cần làm (to-do list).</li>\n</ul>\n<h3>3. <strong>Thực Hành DOM và Xử Lý Sự Kiện</strong></h3>\n<ul>\n<li><strong>DOM</strong>: Làm quen với cách truy xuất và thao tác các phần tử trên trang web.</li>\n<li><strong>Sự kiện</strong>: Học cách phản hồi hành động người dùng như click chuột, nhập liệu.</li>\n</ul>\n<figure class=\"post__image\">                                <img loading=\"lazy\"  src=\"file:///C:/Users/lamqu/OneDrive/Tài liệu/Publii/sites/myblog/input/media/posts/5/javascript-la-gi-ung-dung-cua-javascript.jpg\" alt=\"\" width=\"417\" height=\"453\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"file:///C:/Users/lamqu/OneDrive/Tài%20liệu/Publii/sites/myblog/input/media/posts/5/responsive/javascript-la-gi-ung-dung-cua-javascript-xs.jpg 640w ,file:///C:/Users/lamqu/OneDrive/Tài%20liệu/Publii/sites/myblog/input/media/posts/5/responsive/javascript-la-gi-ung-dung-cua-javascript-sm.jpg 768w ,file:///C:/Users/lamqu/OneDrive/Tài%20liệu/Publii/sites/myblog/input/media/posts/5/responsive/javascript-la-gi-ung-dung-cua-javascript-md.jpg 1024w ,file:///C:/Users/lamqu/OneDrive/Tài%20liệu/Publii/sites/myblog/input/media/posts/5/responsive/javascript-la-gi-ung-dung-cua-javascript-lg.jpg 1366w ,file:///C:/Users/lamqu/OneDrive/Tài%20liệu/Publii/sites/myblog/input/media/posts/5/responsive/javascript-la-gi-ung-dung-cua-javascript-xl.jpg 1600w ,file:///C:/Users/lamqu/OneDrive/Tài%20liệu/Publii/sites/myblog/input/media/posts/5/responsive/javascript-la-gi-ung-dung-cua-javascript-2xl.jpg 1920w\"></figure>\n<hr>\n<h2>Những Tính Năng Nổi Bật Của ES6+</h2>\n<p>ES6 (ECMAScript 6) đã mang đến một loạt cải tiến giúp lập trình JavaScript dễ dàng hơn:</p>\n<ul>\n<li><strong>Arrow Functions</strong>: Cú pháp gọn gàng hơn cho các hàm.</li>\n<li><strong>Template Literals</strong>: Cho phép chèn biến trực tiếp vào chuỗi.</li>\n<li><strong>Modules</strong>: Quản lý mã nguồn tốt hơn với khả năng chia tách module.</li>\n</ul>\n<hr>\n<h2>Định Hướng Tương Lai Với JavaScript</h2>\n<p>Với JavaScript, bạn có thể khám phá nhiều lĩnh vực thú vị như:</p>\n<ul>\n<li><strong>Phát triển web</strong>: Sử dụng các framework như React, Angular, hoặc Vue.js.</li>\n<li><strong>Ứng dụng di động</strong>: Dùng React Native hoặc Flutter để phát triển ứng dụng đa nền tảng.</li>\n<li><strong>Trí tuệ nhân tạo (AI)</strong>: Kết hợp với các thư viện như TensorFlow.js để xây dựng các ứng dụng AI.</li>\n</ul>\n<p>JavaScript không chỉ là một ngôn ngữ lập trình mà còn là cánh cửa mở ra thế giới công nghệ hiện đại. Nếu bạn đang tìm kiếm một ngôn ngữ để bắt đầu hoặc phát triển sự nghiệp, JavaScript chắc chắn là một lựa chọn không thể bỏ qua.</p>\n<p><br><br></p>",
            "author": {
                "name": "Lâm Quang Minh"
            },
            "tags": [
            ],
            "date_published": "2024-12-26T12:57:45+07:00",
            "date_modified": "2024-12-26T12:58:16+07:00"
        },
        {
            "id": "https://github.com/quangminh2k3/my1blog.git/blog-01_.html",
            "url": "https://github.com/quangminh2k3/my1blog.git/blog-01_.html",
            "title": "Blog 01_ Tôi đã học lập trình web như thế nào?",
            "summary": "Giới Thiệu Bản Thân Xin chào! Tôi là Lâm Quang Minh, sinh năm 2003 và hiện là sinh viên năm cuối tại trường Đại học Công nghệ TP.HCM (HUTECH). Trong hành trình học tập tại HUTECH, tôi đã có cơ hội khám phá và đam&hellip;",
            "content_html": "<h2 data-pm-slice=\"1 1 []\">Giới Thiệu Bản Thân</h2>\n<p>Xin chào! Tôi là <strong>Lâm Quang Minh</strong>, sinh năm 2003 và hiện là sinh viên năm cuối tại trường Đại học Công nghệ TP.HCM (HUTECH). Trong hành trình học tập tại HUTECH, tôi đã có cơ hội khám phá và đam mê lập trình mạng, một lĩnh vực đầy thách thức nhưng cũng rất thú vị. Bài viết này, tôi muốn chia sẻ về hành trình học tập và những kinh nghiệm quý báu mà tôi đã tích lũy được.</p>\n<div><hr></div>\n<h2>Hành Trình Học Lập Trình Mạng</h2>\n<h3>1. Khởi Đầu Với Sự Tò Mò</h3>\n<p>Ngay từ những ngày đầu học ngành Công nghệ Thông tin, tôi đã bị cuốn hút bởi cách các thiết bị kết nối với nhau qua mạng. Từ những bài học cơ bản về giao thức mạng, tôi bắt đầu tìm hiểu thêm về cách dữ liệu được truyền tải và bảo mật trong thế giới số. Sự tò mò này đã trở thành động lực giúp tôi đi sâu hơn vào lĩnh vực lập trình mạng.</p>\n<figure class=\"post__image align-center\">                           <img loading=\"lazy\"  src=\"https://github.com/quangminh2k3/my1blog.git/media/posts/1/istockphoto-1309893470-612x612-2.jpg\" alt=\"\" width=\"462\" height=\"375\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/istockphoto-1309893470-612x612-2-xs.jpg 640w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/istockphoto-1309893470-612x612-2-sm.jpg 768w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/istockphoto-1309893470-612x612-2-md.jpg 1024w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/istockphoto-1309893470-612x612-2-lg.jpg 1366w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/istockphoto-1309893470-612x612-2-xl.jpg 1600w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/istockphoto-1309893470-612x612-2-2xl.jpg 1920w\"></figure>\n<h3>2. Những Bước Đầu Tiên</h3>\n<p>Hành trình học lập trình mạng bắt đầu bằng việc nắm vững các kiến thức nền tảng:</p>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Mạng máy tính cơ bản</strong>: Hiểu cách hoạt động của giao thức TCP/IP, DNS, HTTP/HTTPS.</p>\n</li>\n<li>\n<p><strong>Lập trình socket</strong>: Đây là một kỹ năng quan trọng. Tôi đã thực hành viết các ứng dụng đơn giản như chat server/client bằng Python.</p>\n</li>\n<li>\n<p><strong>Bảo mật mạng</strong>: Tôi tìm hiểu về các lỗ hổng bảo mật phổ biến và cách phòng chống như mã hóa dữ liệu và sử dụng tường lửa.</p>\n</li>\n</ul>\n<h3>3. Học Qua Dự Án Thực Tế</h3>\n<p>Để củng cố kiến thức, tôi tham gia nhiều dự án nhỏ:</p>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Phân tích gói tin mạng</strong>: Tôi tìm hiểu cách dữ liệu được truyền trên mạng.</p>\n</li>\n<li>\n<p><strong>Mô phỏng VPN</strong>: Tôi đã thực hiện một bài tập lớn về VPN để hiểu rõ cách dữ liệu được bảo mật khi truyền tải qua mạng.</p>\n</li>\n</ul>\n<h3>4. Tài Liệu Học Tập và Công Cụ Hỗ Trợ</h3>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Sách và khóa học online</strong>:</p>\n<ul data-spread=\"false\">\n<li>\n<p><em>Computer Networking: Principles, Protocols, and Practice</em> của Olivier Bonaventure.</p>\n</li>\n<li>\n<p>Các khóa học trên Udemy và Coursera.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Công cụ thực hành</strong>:</p>\n<ul data-spread=\"false\">\n<li>\n<p>Wireshark: Phân tích gói tin mạng.</p>\n</li>\n<li>\n<p>Cisco Packet Tracer: Mô phỏng mạng máy tính.</p>\n</li>\n<li>\n<p>VirtualBox: Cài đặt và kiểm thử mạng ảo.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>5. Bài Học Kinh Nghiệm</h3>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Tư duy hệ thống</strong>: Lập trình mạng không chỉ là viết mã mà còn cần hiểu cách các thành phần phối hợp với nhau.</p>\n</li>\n<li>\n<p><strong>Không ngừng thực hành</strong>: Thực hành liên tục giúp tôi hiểu rõ và áp dụng kiến thức vào thực tế.</p>\n</li>\n<li>\n<p><strong>Tìm cộng đồng</strong>: Tham gia các diễn đàn như Stack Overflow, GitHub và nhóm học tập trong trường giúp tôi học hỏi từ những người đi trước.</p>\n</li>\n</ul>\n<div><hr></div>\n<h2>Định Hướng Tương Lai</h2>\n<p>Trong tương lai, tôi dự định sẽ:</p>\n<ul data-spread=\"false\">\n<li>\n<p>Học sâu hơn về <strong>Cloud Networking</strong> và<strong> mạng máy tính</strong>.</p>\n</li>\n<li>\n<p>Xây dựng các dự án thực tế như hệ thống quản lý mạng cho doanh nghiệp.</p>\n</li>\n<li>\n<p>Chia sẻ kiến thức và giúp đỡ các bạn trẻ đam mê lĩnh vực này.</p>\n</li>\n</ul>\n<div><hr></div>\n<p>Cảm ơn bạn đã đọc bài viết! Nếu bạn có cùng sở thích hoặc muốn trao đổi thêm về lập trình mạng, đừng ngần ngại liên hệ với tôi. Hành trình của chúng ta sẽ trở nên thú vị hơn khi có những người bạn đồng hành! Sau đây là một số chứng chỉ mà tôi đã đạt được trong quá trình học môn Lập trình mạng máy tính:</p>\n<figure class=\"post__image\"><img  src=\"https://github.com/quangminh2k3/my1blog.git/media/posts/1/JavaScript_Essentials_1_Badge20241214-28-wxy1fw.pdf\" alt=\"\" width=\"NaN\" height=\"NaN\"></figure>            <figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://github.com/quangminh2k3/my1blog.git/media/posts/1/1.png\" alt=\"\" width=\"544\" height=\"421\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/1-xs.png 640w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/1-sm.png 768w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/1-md.png 1024w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/1-lg.png 1366w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/1-xl.png 1600w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/1-2xl.png 1920w\"> </figure>\n<figure class=\"post__image\">           <img loading=\"lazy\"  src=\"https://github.com/quangminh2k3/my1blog.git/media/posts/1/2.png\" alt=\"\" width=\"549\" height=\"425\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/2-xs.png 640w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/2-sm.png 768w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/2-md.png 1024w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/2-lg.png 1366w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/2-xl.png 1600w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/2-2xl.png 1920w\"> </figure>\n<figure class=\"post__image\">          <img loading=\"lazy\"  src=\"https://github.com/quangminh2k3/my1blog.git/media/posts/1/3.png\" alt=\"\" width=\"531\" height=\"409\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/3-xs.png 640w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/3-sm.png 768w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/3-md.png 1024w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/3-lg.png 1366w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/3-xl.png 1600w ,https://github.com/quangminh2k3/my1blog.git/media/posts/1/responsive/3-2xl.png 1920w\"></figure>",
            "author": {
                "name": "Lâm Quang Minh"
            },
            "tags": [
            ],
            "date_published": "2024-12-25T21:51:49+07:00",
            "date_modified": "2024-12-26T15:01:43+07:00"
        }
    ]
}
